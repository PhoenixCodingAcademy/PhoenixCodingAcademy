{% extends 'base.html' %}
{% block content %}

<style>
  #exam-form > div > label {
    display: inline-block;
    width: 200px;
    text-align: right;
    margin-right: 10px;
  }
  
  .searchable-dropdown {
    position: relative;
    display: inline-block;
    width: 300px;
  }
  
  .searchable-dropdown input {
    width: 100%;
    padding: 5px;
    box-sizing: border-box;
  }
  
  .dropdown-list {
    position: absolute;
    top: 100%;
    left: 0;
    right: 0;
    max-height: 200px;
    overflow-y: auto;
    background: white;
    border: 1px solid #ccc;
    border-top: none;
    z-index: 1000;
    box-shadow: 0 2px 4px rgba(0,0,0,0.2);
  }
  
  .dropdown-item {
    padding: 8px 12px;
    cursor: pointer;
    border-bottom: 1px solid #eee;
  }
  
  .dropdown-item:hover {
    background-color: #f0f0f0;
  }
  
  .dropdown-item.selected {
    background-color: #e3f2fd;
    font-weight: bold;
  }
</style>

{% raw %}<div id="exam-app">
  <form id="exam-form" @submit.prevent="gradeExam">
    <div>
      <label for="yaml-select"><strong>Question set:</strong></label>
      <div class="searchable-dropdown">
        <input 
          type="text" 
          v-model="searchText"
          @focus="dropdownOpen = true"
          @blur="handleBlur"
          :placeholder="selectedYaml || 'Type to search...'"
        />
        <div v-if="dropdownOpen && filteredYamlFiles.length" class="dropdown-list">
          <div 
            v-for="file in filteredYamlFiles" 
            :key="file" 
            :class="['dropdown-item', {selected: file === selectedYaml}]"
            @mousedown="selectFile(file)"
          >
            [[ file ]]
          </div>
        </div>
      </div>
    </div>
    <div>
      <label for="name"><strong>Name:</strong></label>
      <input id="name" v-model="studentName" type="text" required placeholder="Your full name; e.g. John Smith" />
    </div>
    <div>
      <label for="max-points"><strong>Max Points:</strong></label>
      <input id="max-points" v-model.number="maxPoints" type="number" min="1" max="200" required />
    </div>
    <div>
      <label for="max-difficulty"><strong>Max difficult question:</strong></label>
      <input id="max-difficulty" v-model.number="maxDifficulty" type="number" min="1" max="20" required />
    </div>
    <div>
      <button type="button" @click="startExam" :disabled="!canStart">Start Exam</button>
    </div>

    <div v-if="started" style="margin-top: 2em;">
      <div>
        <h2>Quiz for [[ studentName ]]</h2>
        <div>[[ examDate ]]</div>
        <div>
          [[ questions.length ]] questions for a total of [[ totalPoints ]] points.
        </div>
      </div>
      
      <div v-if="sessionHistory && sessionHistory.length" style="margin-top: 1em; padding: 10px; background-color: #f5f5f5; border-radius: 5px;">
        <h4>Session History:</h4>
        <div v-for="(entry, idx) in sessionHistory" :key="'history-' + idx" style="margin: 5px 0;">
          [[ entry ]]
        </div>
      </div>
      <hr>
      <div v-for="(q, qIdx) in questions" :key="'q-'+qIdx" style="margin-bottom:1.5em;">
        <h3 :style="getQuestionStyle(qIdx)">
          Q[[ qIdx+1 ]]. [[ q.question ]] ([[ q.points ]] pts)
        </h3>
        <div v-for="(ans, aIdx) in q.displayAnswers" :key="ans.uid">
          <label :style="getAnswerStyle(qIdx, ans)">
            <input type="checkbox"
                   :id="ans.uid"
                   :name="'q-' + qIdx"
                   :value="ans.uid"
                   v-model="answers[qIdx]"
                   :disabled="graded"
                   @change="answerChanged(qIdx, aIdx, ans.isNoneOfTheAbove)">
            [[ ans.answer ]]
          </label>
          <div v-if="showAnswers && ans.explanation" style="margin-left: 30px; font-size: 0.9em; color: #666;">
            [[ ans.explanation ]]
          </div>
        </div>
      </div>
      <div v-if="!graded">
        <button type="submit" :disabled="!readyToGrade">Grade Quiz</button>
      </div>
      <div v-else>
        <button type="button" @click.prevent="tryAgain" v-if="!allCorrect">Try Again</button>
        <button type="button" @click.prevent="revealAnswers" v-if="!showAnswers" :style="allCorrect ? '' : 'margin-left: 10px;'">Show Answers</button>
      </div>
    </div>
  </form>
  <div v-if="results" style="margin-top: 2em;">
    <h3>Results</h3>
    <div>
      Name: [[ results.name ]]<br>
      Score: [[ results.score ]] / [[ results.maxPoints ]]<br>
      <span v-if="allCorrect" style="color: green; font-weight: bold;">Perfect Score! ðŸŽ‰</span>
    </div>
  </div>
</div>{% endraw %}

<script src="https://cdn.jsdelivr.net/npm/vue@2"></script>
<script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/xxhashjs@0.2.2/build/xxhash.min.js"></script>
<script>
var yamlFiles = [];
{% for file in model.yamlFiles %}
yamlFiles.push('{{ file }}');
{% endfor %}
new Vue({
  el: '#exam-app',
  delimiters: ['[[', ']]'],
  data: {
    yamlFiles: yamlFiles,
    selectedYaml: localStorage.getItem('selectedYaml') || '',
    searchText: '',
    dropdownOpen: false,
    studentName: localStorage.getItem('studentName') || '',
    maxPoints: parseInt(localStorage.getItem('maxPoints')) || 50,
    maxDifficulty: parseInt(localStorage.getItem('maxDifficulty')) || 7,
    started: false,
    allQuestions: [],
    questions: [],
    answers: [],
    history: [],
    sessionHistory: [],
    examDate: '',
    totalPoints: 0,
    results: null,
    graded: false,
    showAnswers: false,
    secret: 'exam_secret_key',  // For hashing IDs
  },
  watch: {
    selectedYaml(newValue) {
      localStorage.setItem('selectedYaml', newValue);
    },
    studentName(newName) {
      localStorage.setItem('studentName', newName);
    },
    maxPoints(newValue) {
      localStorage.setItem('maxPoints', newValue);
    },
    maxDifficulty(newValue) {
      localStorage.setItem('maxDifficulty', newValue);
    }
  },
  computed: {
    canStart() {
      return this.selectedYaml && this.studentName && this.maxPoints && this.maxDifficulty;
    },
    readyToGrade() {
      if (!this.questions.length) return false;
      // All questions must have at least one checked value
      return this.answers.length === this.questions.length && this.answers.every(arr => arr && arr.length > 0);
    },
    allCorrect() {
      if (!this.results || !this.results.answers) return false;
      return this.results.answers.every(a => a.right);
    },
    filteredYamlFiles() {
      if (!this.searchText) {
        return this.yamlFiles;
      }
      const search = this.searchText.toLowerCase();
      return this.yamlFiles.filter(file => file.toLowerCase().includes(search));
    }
  },
  methods: {
    resetExam() {
      this.started = false;
      this.allQuestions = [];
      this.questions = [];
      this.answers = [];
      this.history = [];
      this.sessionHistory = [];
      this.examDate = '';
      this.totalPoints = 0;
      this.results = null;
      this.graded = false;
      this.showAnswers = false;
    },
    initYamlSelection() {
      // Set the first yaml file as the default selection if not already set
      if (!this.selectedYaml && this.yamlFiles.length) {
        this.selectedYaml = this.yamlFiles[0];
      }
    },
    selectFile(file) {
      this.selectedYaml = file;
      this.searchText = '';
      this.dropdownOpen = false;
      this.resetExam();
    },
    handleBlur() {
      // Delay to allow click event to fire
      setTimeout(() => {
        this.dropdownOpen = false;
        this.searchText = '';
      }, 200);
    },
    startExam() {
      if (!this.canStart) return;
      this.results = null;
      this.started = false;
      this.graded = false;
      this.showAnswers = false;
      this.answers = [];
      this.questions = [];
      this.history = [];
      this.examDate = new Date().toISOString().slice(0,10);

      // POST to API for exam generation
      axios.post('/startexam', {
        selectedYaml: this.selectedYaml,
        maxPoints: this.maxPoints,
        maxDifficulty: this.maxDifficulty
      })
        .then(res => {
          this.questions = res.data.questions || [];
          this.totalPoints = res.data.totalPoints || 0;
          this.history = res.data.history || [];
          this.answers = Array(this.questions.length).fill().map(()=>[]);
          this.started = true;
        })
        .catch(e => {
          alert("Failed to start exam: " + (e.response?.data?.error || e.message));
        });
    },
    answerChanged(qIdx, aIdx, isNoneOfTheAbove) {
      // If "None of the above" is checked, uncheck others and vice versa
      let anArr = this.answers[qIdx] || [];
      let q = this.questions[qIdx];
      let noneIdx = q.displayAnswers.findIndex(a => a.isNoneOfTheAbove);
      if (noneIdx === -1) return;
      let noneUid = q.displayAnswers[noneIdx].uid;

      // If "None of the above" is being selected, set to only that
      if (this.answers[qIdx].includes(noneUid)) {
        this.answers[qIdx] = [noneUid];
      } else {
        // If any other checkbox is checked, uncheck "None of the above"
        this.answers[qIdx] = this.answers[qIdx].filter(uid => uid !== noneUid);
      }
      // Always update to force Vue reactivity
      this.$set(this.answers, qIdx, this.answers[qIdx]);
    },
    gradeExam() {
      // Gather answers and post to /gradeexam
      let answerObjs = [];
      for (let qi=0; qi<this.questions.length; ++qi) {
        let q = this.questions[qi];
        let selUids = this.answers[qi] || [];
        let selectedAnswers = q.displayAnswers.filter(a => selUids.includes(a.uid));
        // Check if all selected answers are correct AND all correct answers are selected
        let selectedCorrect = selectedAnswers.filter(a => a.isRight);
        let allCorrectAnswers = q.displayAnswers.filter(a => a.isRight);
        let isRight = selectedCorrect.length > 0 && 
                      selectedAnswers.length === selectedCorrect.length &&
                      selectedCorrect.length === allCorrectAnswers.length;
        answerObjs.push({
          selected: selUids,
          right: isRight,
          points: q.points
        });
      }
      axios.post('/gradeexam', {
        name: this.studentName,
        maxPoints: this.totalPoints,
        maxDifficulty: this.maxDifficulty,
        history: this.history,
        answers: answerObjs
      })
      .then(res => {
        this.results = res.data.results || res.data;
        this.graded = true;
        
        // Add to session history
        let missed = answerObjs.filter(a => !a.right).length;
        let score = this.results.score || 0;
        let timestamp = new Date().toLocaleTimeString();
        this.sessionHistory.push(`${timestamp} - Grade Quiz: ${score}/${this.totalPoints} points, ${missed} question(s) missed`);
        
        // If all correct, auto-reveal answers
        if (this.allCorrect) {
          this.showAnswers = true;
        }
      })
      .catch(e => {
        alert("Error submitting exam: " + e);
      });
    },
    tryAgain() {
      // Reset state first
      this.graded = false;
      this.showAnswers = false;
      
      // Add to history
      let timestamp = new Date().toLocaleTimeString();
      this.sessionHistory.push(`${timestamp} - Try Again: Resetting quiz to reattempt`);
      
      // Don't clear results yet so we can still see the score
      // But the checkboxes will be re-enabled and grading view hidden
    },
    revealAnswers() {
      let timestamp = new Date().toLocaleTimeString();
      let score = this.results ? this.results.score : 0;
      let missed = this.results && this.results.answers ? this.results.answers.filter(a => !a.right).length : 0;
      this.sessionHistory.push(`${timestamp} - Show Answers: Revealed answers (Score: ${score}/${this.totalPoints}, ${missed} missed)`);
      
      this.showAnswers = true;
    },
    getQuestionStyle(qIdx) {
      if (!this.graded || !this.results || !this.results.answers) return '';
      
      // Green if correct, red if wrong
      if (this.results.answers[qIdx].right) {
        return 'color: green;';
      } else {
        return 'color: red;';
      }
    },
    getAnswerStyle(qIdx, ans) {
      let selUids = this.answers[qIdx] || [];
      let isSelected = selUids.includes(ans.uid);
      
      // After grading, highlight selected answers
      if (this.graded && !this.showAnswers) {
        // Just show what was selected without revealing correctness yet
        if (isSelected) {
          // Check if this question was answered correctly
          let isQuestionCorrect = this.results && this.results.answers && this.results.answers[qIdx].right;
          if (isQuestionCorrect) {
            return 'color: green; font-weight: bold;';
          }
        }
        return '';
      }
      
      // When showing answers, reveal all correct/incorrect
      if (this.showAnswers) {
        // Show wrong answers in red if they were selected
        if (isSelected && !ans.isRight) {
          return 'color: red; font-weight: bold;';
        }
        // Show correct answers in green when revealing
        if (ans.isRight) {
          return 'color: green; font-weight: bold;';
        }
      }
      
      return '';
    }
  },
  mounted() {
    this.initYamlSelection();
  }
});
</script>


{% endblock %}